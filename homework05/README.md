# Домашнее задание №5
## BASH скрипт
Скрипт сохраняет результат в файл **result_bash.txt**

Для каждой однострочной команды добавлен вывод информации о результате с помощью **echo**,
а так же результат форматируется в соответствии с заданием с помощью **awk**.

### Общее количество запросов
```bash
cat access.log | wc -l | awk '{print $1}' >> $result
```

Команда **wc -l** выполняет подсчет всех строк в файле **access.log**.

### Общее количество запросов по типу
```bash
cat access.log | awk '{gsub(/"/, "", $6); print $6}' | sort | uniq -c | sort -rnk 2 | awk '{printf "%s-%d\n", $2, $1}' >> $result
```

Сначала оставим только названия типов с помощью **awk**, отсортируем с помощью **sort**,
чтобы подсчитать количество вхождений каждого типа с помощью **uniq -c** и отсортируем по количеству.
В файле **access.log** присутствует один запрос, у которого на позиции **type** стоит нестандартный тип, но так как
лог файл имеет строгий формат, то и данный нестандартный тип запроса не будем убирать, иначе можно пропустить возможный
баг в приложении.

### 10 самых частых запросов
```bash
cat access.log | awk '{print $7}' | sort | uniq -c | sort -rnk 1 | head | awk '{print $2,$1}' >> $result
```

Сначала оставим только location с помощью **awk**, отсортируем с помощью **sort**,
чтобы подсчитать количество вхождений каждого location с помощью **uniq -c** и отсортируем по количеству.

### Топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой
```bash
cat access.log | awk '$9 ~ /4[0-9]{2}$/ {print $1,$7,$9,$10}' | sort -rnk 4 | head -n 5 | awk '{print $2,$3,$4,$1}' >> $result
```

Сначала оставим только ip, location, status, size если status соотвествует 4XX, отсортируем с помощью **sort**
по size по убыванию и возьмем первые 5 строк с помощью **head**.

### Топ 5 пользователей по количеству запросов, которые завершились серверной (5ХХ) ошибкой
```bash
cat access.log | awk '$9 ~ /5[0-9]{2}$/ {print $1}' | sort -k 1 | uniq -c | sort -rnk 1 | head -n 5 | awk '{print $2,$1}' >> $result
```

Оставляем только ip, если status соответствует 5XX, сортируем, чтобы с помощью **uniq** подсчитать
количество вхождений каждого ip, сортируем по убыванию и берем первые 5.

## PYTHON скрипт
Если скрипт был запущен с флагом **--json**, то результат сохраняется в JSON-файл **result_python.json**,
иначе результат сохраняется в текстовом формате в файл **result_python.txt**.

### Чтение файла access.log
```python
with open("access.log") as log:
    lines = [line.split(' ') for line in log
```

Считываем каждую строку, разбиваем ее с разделителем пробел и записываем в массив **lines**.

### Общее количество запросов
```python
result['Task 01'] = {'count': sum(1 for _ in lines)}
```

Считаем количество строк.

### Общее количество запросов по типу
```python
types_counted = Counter([line[5].strip('"') for line in lines])
result['Task 02'] = [
    {'type': r_type, 'count': value}
    for r_type, value in sorted(types_counted.items(), key=lambda item: item[1], reverse=True)
]
```

С помощью библиотеки **Counter** считаем количество вхождений каждого типа и сортируем по убыванию.

### 10 самых частых запросов
```python
locations_counted = Counter([line[6] for line in lines])
result['Task 03'] = [
    {'location': url, 'count': value}
    for url, value in sorted(locations_counted.items(), key=lambda item: item[1], reverse=True)[:10]
]
```

Считаем количество вхождений каждого **location**, сортируем по убыванию и берем первые 10.

### Топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой
```python
client_error_requests = [
    {'ip': line[0], 'location': line[6], 'status': line[8], 'size': int(line[9])}
    for line in lines if re.match('4[0-9]{2}$', line[8])
]
result['Task 04'] = [
    request for request in sorted(client_error_requests, key=lambda item: item['size'], reverse=True)[:5]
]
```

Берем все запросы, у которых **status** соответствует 4XX, сортируем по **size** по убыванию и берем первые 5.

### Топ 5 пользователей по количеству запросов, которые завершились серверной (5ХХ) ошибкой
```python
server_error_clients_counted = Counter([line[0] for line in lines if re.match('5[0-9]{2}$', line[8])])
result['Task 05'] = [
    {'ip': ip, 'count': value}
    for ip, value in sorted(server_error_clients_counted.items(), key=lambda item: item[1], reverse=True)[:5]
]
```

Считаем количество вхождений каждого **ip**, у которых **status** соответствует 5XX,
сортируем по убыванию и берем первые 5.


## Вывод
### BASH
#### Преимущества 
* Удобнее работа с файлами, если нужен простой ввод/вывод
* Не нужен компилятор/интерпретатор
* Возможность писать команды в одну строку благодаря пайпам
* Удобнее для простых скриптов
#### Недостатки
* Необходимо знать множество команд
* Легче допустить ошибки
* Понимает только текст

### PYTHON
#### Преимущества
* Поддержка ООП
* Множество библиотек
* Удобнее для сложных скриптов
#### Недостатки
* Намного больше кода
